import os
from dotenv import load_dotenv

load_dotenv()
# 4/15 unset proxy

env_proxy = [
    "http_proxy", "https_proxy", "ftp_proxy", "all_proxy",
    "HTTP_PROXY", "HTTPS_PROXY", "FTP_PROXY", "ALL_PROXY"
]

original_env = {}
for i in env_proxy:
    # ----- Step 1: Backup original proxy settings -----
    original_env[i] = os.environ.get(i)
    # ----- Step 2: Temporarily clear proxy -----
    os.environ.pop(i, None)


import asyncio
from openai import AsyncOpenAI
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy import text

client = AsyncOpenAI(
    api_key=os.getenv("OPENAI_API_KEY"),
    base_url=os.getenv("OPENAI_BASE_URL"),
    # proxies= None
)

DB_USERNAME = os.getenv("DB_USERNAME")
DB_PASSWORD = os.getenv("DB_PASSWORD")
DB_HOST = os.getenv("DB_HOST", "127.0.0.1")
DB_PORT = int(os.getenv("DB_PORT", 3306))
TARGET_DB = os.getenv("TARGET_DB")

DATABASE_URL = f"mysql+aiomysql://{DB_USERNAME}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{TARGET_DB}"
engine = create_async_engine(DATABASE_URL, echo=False)
SessionLocal = async_sessionmaker(bind=engine, expire_on_commit=False, class_=AsyncSession)

# ----------------------
# ðŸ“˜ Prompt
# ----------------------
SYSTEM_PROMPT = """You are an SQL generator. Please generate MySQL queries based on natural language requests. The data structure is as follows:

- model(model_id, model_name, param_num, media_type, arch_name)
- model_tasks(model_id, task_name)
- cnn(model_id, module_num)
- transformer(model_id, decoder_num, attn_size, up_size, down_size, embed_size)
- rnn(model_id, criteria, batch_size, input_size)
- dataset(ds_id, ds_name, ds_size, media, task)
- ds_col(ds_id, col_name, col_datatype)
- user(user_id, user_name, affiliate)
- affil(affil_id, affil_name)
- user_affil(user_id, affil_id)
- model_author(model_id, user_id)
- model_dataset(model_id, dataset_id)
- user_ds(user_id, ds_id)

Only return the SQL query. Do not add explanations.
"""

# ----------------------
# ðŸ” Generate SQL with GPT
# ----------------------
async def natural_language_to_sql(nl_input: str) -> str:
    response = await client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": nl_input}
        ],
        temperature=0,
    )
    return response.choices[0].message.content.strip("` \n")

# ----------------------
# âŒ Error Fixing
# ----------------------
async def fix_sql_with_error(nl_input: str, original_sql: str, error_msg: str) -> str:
    fix_prompt = f"""
The original natural language request is:
{nl_input}

The generated SQL is:
{original_sql}

The following error occurred during execution:
{error_msg}

Please fix this SQL query and return a correct SQL query.
"""
    response = await client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": fix_prompt}
        ],
        temperature=0,
    )
    return response.choices[0].message.content.strip("` \n")

# ----------------------
# ðŸ“¦ Execute SQL
# ----------------------
async def execute_sql(sql: str):
    async with SessionLocal() as session:
        try:
            result = await session.execute(text(sql))
            rows = result.fetchall()
            columns = result.keys()
            return [dict(zip(columns, row)) for row in rows], None
        except Exception as e:
            return None, str(e)

# ----------------------
# ðŸš€ Main Execution Logic
# ----------------------
async def query_agent(nl_input: str):
    print("ðŸŽ¯ User input:", nl_input)

    sql = await natural_language_to_sql(nl_input)
    print("\nðŸ§  SQL generated by GPT:", sql)

    result, error = await execute_sql(sql)

    if error:
        print("\nâš ï¸ Execution error, attempting to fix...")
        fixed_sql = await fix_sql_with_error(nl_input, sql, error)
        print("\nðŸ” Fixed SQL:", fixed_sql)
        result, error = await execute_sql(fixed_sql)

        if error:
            print("\nâŒ Fix failed:", error)
        else:
            print("\nâœ… Fix succeeded, results are as follows:")
            print(result)
    else:
        print("\nâœ… Execution succeeded, results are as follows:")
        print(result)

# ----------------------
# ðŸ CLI Entry Point
# ----------------------
async def main():
    
    try:
        while True:
            nl_input = input("ðŸ“ Please input your natural language query:\n> ")
            await query_agent(nl_input)
            print("Would you like to continue? (y/n)")
            choice = input("> ")
            
            if choice.lower() == 'n':
                print("Goodbye!")
                break
        
    finally:
        # Step 3: Restore proxy environment variables
        for key, value in original_env.items():
            if value is not None:
                os.environ[key] = value
        # Step 4: Properly release database resources
        await engine.dispose()

if __name__ == "__main__":
    asyncio.run(main())